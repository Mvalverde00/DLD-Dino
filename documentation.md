# Technical Description

Our project is a platform runner game based on the google chrome dinosaur game, in which the player makes an animated dinosaur avoid obstacles. We built an LED matrix to display the game. The dinosaur character is represented by two vertical LEDs, and is controlled by the user’s inputs. The character jumps or ducks depending on the input of the player, in order to avoid obstacles. These obstacles are composed of different arrangements of either 2, 4, or 6 LED’s.

<img align='right' src='https://raw.githubusercontent.com/Mvalverde00/DLD-Dino/master/full-game-display.jpg' style="width:320px; height:200px">
Our display is constructed of a 7x17 led matrix. The bottom horizontal row represents the ground, and is composed of 17 yellow LEDs that are always on. The second vertical column from the left is reserved for the vertical up and down functions of the dinosaur and is represented by green LEDs. This column is controlled by two bi-directional shift registers. The rest of the LEDs represent the obstacles, and are controlled by shift registers. Random values are generated to decide what type of obstacle to produce, how many, and at what height. These obstacles are then shifted left until they collide with the dinosaur. The game’s difficulty/speed is determined automatically based on the score. The input consists of 2 buttons for jumping and for ducking on a laser cut enclosure, which also holds the display at a 30 degree angle. The score is based on time, and is displayed on 7 segment displays. The game ends when the player collides with one of the obstacles.

To generate the obstacles, we first need to decide which obstacle to spawn, at what height to spawn it, and how many to spawn. This is done by taking the output of the random number generator and using the first bit to choose the obstacle. That bit goes into one demux, while the inverted output goes to a second demux (and each demux’s inhibit pin receives the opposite value of its input pin). If the first bit is a 0, the demux designated for cacti is activated, and if it is a 1, the demux for birds is activated. The 2nd, 3rd, and 4th bits of the random number are used to determine the height of any birds that are spawned. These bits go into the address  pins of the demux for the bird, and each respective output of the demux parallel-loads in the 2 horizontal spots on the shift register for the correct row(height). The 5th and 6th bits of the random number generator go into the address pins of the other demux, which is for the cacti. Depending on the output of the demux, the correct number of cacti are loaded into the shift registers. When this loading takes place is controlled by a clock connected to a counter, which puts the first column of shift registers into parallel loading mode when the counter reaches 5, and then puts them back into serial mode and resets the counter.
    
Jumping is achieved by sending clock pulses to a bidirectional shift register containing the dinosaur’s position. To achieve this, the button press toggles a J-K flip-flop, which is anded with a clock. The resulting signal clocks the shift register as well as a decade counter.  After clocking a certain number of times - 4 if the button is being held, or 2 if the button was merely tapped - the decade counter output will reset the J-K flip-flop, turning off the clock.  While toggled on, the J-K flip-flop also sets the bidirectional shift registers to shift-left mode.  After the J-K flip-flop has been toggled off and the dinosaur has jumped, he must fall back to the ground. This is accomplished by setting the bidirectional shift registers to shift-right mode, and sending clock pulses until the dinosaur is back on the ground.  See LogiSim schematic for example.

Ducking must turn off the second LED and is accomplished by checking if the dinosaur is on the ground, and anding the result with the duck-button press.  That is to say, if the dinosaur is on the ground, and if the duck button is being pressed, his upper hitbox is temporarily ignored (set to 0).
    
The player’s score starts at 0 and can go all the way up to 999.  This is accomplished using 3 BCD Decade up counters.  A clock is fed into first decade counter, which controls the ones place. When this counter reaches 10, it resets itself to 0 and sends a pulse to the clock pin on the next counter.  Thus, the second counter will increment by 1 after the first counter has incremented by 10.  Similarly when the second counter reaches 10, it resets itself to 0 and sends a pulse to the clock pin on the third counter.  Thus, the third counter will increment by 1 for every 10 pulses the second counter receives and every 100 pulses the first counter receives.  The player’s score is then display on 3 7-segment displays.  The player’s score is also used to control difficulty by speeding up the game: the main game clock receives one of its resistor values from a demux.  The output from the hundreds place counter is fed into the demux’s address pins.  For example, a value of 0 in the hundreds place (score 0-99), corresponds to the resistor at Y0 on the demux.  A value of 7-9 in the hundreds place (score 700-999), corresponds to the resistor at Y7 on the demux.  Similar mapping is done for the scores in between, resulting in a gradual shift in the game’s speed from roughly 2 Hz to 4 Hz.
